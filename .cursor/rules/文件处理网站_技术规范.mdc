---
description: 
globs: 
alwaysApply: false
---
# 文件处理网站技术规范

## 1. API接口规范

### 1.1 基础规范
- **协议**：HTTP/HTTPS
- **格式**：JSON
- **编码**：UTF-8
- **版本**：v1
- **基础路径**：`/api/v1`

### 1.2 通用响应格式
```json
{
  "success": true,
  "code": 200,
  "message": "操作成功",
  "data": {},
  "timestamp": "2025-01-XX 10:00:00"
}
```

### 1.3 错误码定义
```json
{
  "200": "成功",
  "400": "请求参数错误",
  "401": "未授权访问",
  "403": "禁止访问",
  "404": "资源不存在",
  "413": "文件过大",
  "415": "不支持的文件类型",
  "429": "请求过于频繁",
  "500": "服务器内部错误",
  "503": "服务暂不可用"
}
```

### 1.4 文件操作API详细设计

#### 1.4.1 文件上传
```http
POST /api/v1/files/upload
Content-Type: multipart/form-data

Request Body:
- files: File[] (必需) - 上传的文件列表
- session_id: string (可选) - 会话ID

Response:
{
  "success": true,
  "data": {
    "files": [
      {
        "file_id": "uuid-string",
        "filename": "document.pdf",
        "size": 1024000,
        "content_type": "application/pdf",
        "upload_time": "2025-01-XX 10:00:00",
        "status": "uploaded"
      }
    ],
    "session_id": "session-uuid"
  }
}
```

#### 1.4.2 获取文件信息
```http
GET /api/v1/files/{file_id}

Response:
{
  "success": true,
  "data": {
    "file_id": "uuid-string",
    "filename": "document.pdf",
    "size": 1024000,
    "content_type": "application/pdf",
    "upload_time": "2025-01-XX 10:00:00",
    "status": "uploaded",
    "download_url": "/api/v1/files/{file_id}/download"
  }
}
```

#### 1.4.3 删除文件
```http
DELETE /api/v1/files/{file_id}

Response:
{
  "success": true,
  "message": "文件删除成功"
}
```

### 1.5 任务管理API详细设计

#### 1.5.1 创建处理任务
```http
POST /api/v1/tasks/create

Request Body:
{
  "file_ids": ["uuid1", "uuid2"],
  "task_type": "full",  // full, text, formula, table
  "options": {
    "split_pages": false,
    "output_format": "markdown"
  }
}

Response:
{
  "success": true,
  "data": {
    "task_id": "task-uuid",
    "status": "pending",
    "created_time": "2025-01-XX 10:00:00",
    "estimated_time": 120
  }
}
```

#### 1.5.2 获取任务状态
```http
GET /api/v1/tasks/{task_id}

Response:
{
  "success": true,
  "data": {
    "task_id": "task-uuid",
    "status": "running",
    "progress": 0.65,
    "current_step": "处理第2个文件",
    "created_time": "2025-01-XX 10:00:00",
    "estimated_remaining": 45,
    "result_files": []
  }
}
```

#### 1.5.3 获取任务列表
```http
GET /api/v1/tasks?session_id={session_id}&status={status}&page={page}&size={size}

Response:
{
  "success": true,
  "data": {
    "tasks": [...],
    "total": 10,
    "page": 1,
    "size": 20
  }
}
```

### 1.6 结果获取API详细设计

#### 1.6.1 获取处理结果
```http
GET /api/v1/results/{task_id}

Response:
{
  "success": true,
  "data": {
    "task_id": "task-uuid",
    "status": "completed",
    "results": [
      {
        "file_id": "result-uuid",
        "filename": "document.md",
        "content_type": "text/markdown",
        "size": 2048,
        "download_url": "/api/v1/results/{task_id}/download/{file_id}"
      }
    ],
    "summary": {
      "total_files": 2,
      "processed_files": 2,
      "failed_files": 0,
      "processing_time": 125
    }
  }
}
```

#### 1.6.2 下载结果文件
```http
GET /api/v1/results/{task_id}/download/{file_id}
GET /api/v1/results/{task_id}/download  # 下载全部结果（ZIP格式）

Response: 文件流
```

### 1.7 WebSocket接口规范

#### 1.7.1 连接建立
```javascript
const ws = new WebSocket('ws://localhost:8000/ws/tasks/{task_id}');
```

#### 1.7.2 消息格式
```json
{
  "type": "progress_update",
  "data": {
    "task_id": "task-uuid",
    "progress": 0.75,
    "current_step": "处理第3个文件",
    "estimated_remaining": 30
  },
  "timestamp": "2025-01-XX 10:00:00"
}
```

## 2. 数据模型设计

### 2.1 Redis数据结构

#### 2.1.1 会话信息
```redis
Key: session:{session_id}
Type: Hash
Fields:
  - created_time: "2025-01-XX 10:00:00"
  - last_activity: "2025-01-XX 10:30:00"
  - file_count: 5
  - task_count: 2
TTL: 86400 (24小时)
```

#### 2.1.2 文件信息
```redis
Key: file:{file_id}
Type: Hash
Fields:
  - filename: "document.pdf"
  - size: 1024000
  - content_type: "application/pdf"
  - upload_time: "2025-01-XX 10:00:00"
  - status: "uploaded"
  - session_id: "session-uuid"
  - file_path: "/storage/uploads/uuid.pdf"
TTL: 86400 (24小时)
```

#### 2.1.3 任务信息
```redis
Key: task:{task_id}
Type: Hash
Fields:
  - status: "running"
  - progress: 0.65
  - current_step: "处理第2个文件"
  - created_time: "2025-01-XX 10:00:00"
  - file_ids: "uuid1,uuid2"
  - task_type: "full"
  - session_id: "session-uuid"
  - result_files: "result1,result2"
TTL: 86400 (24小时)
```

#### 2.1.4 任务队列
```redis
Key: task_queue
Type: List
Values: ["task_id1", "task_id2", ...]
```

### 2.2 Python数据模型

#### 2.2.1 文件信息模型
```python
from pydantic import BaseModel
from datetime import datetime
from typing import Optional
from enum import Enum

class FileStatus(str, Enum):
    UPLOADED = "uploaded"
    PROCESSING = "processing"
    COMPLETED = "completed"
    ERROR = "error"

class FileInfo(BaseModel):
    file_id: str
    filename: str
    size: int
    content_type: str
    upload_time: datetime
    status: FileStatus
    session_id: str
    file_path: str
    error_message: Optional[str] = None
```

#### 2.2.2 任务模型
```python
class TaskType(str, Enum):
    FULL = "full"
    TEXT = "text"
    FORMULA = "formula"
    TABLE = "table"

class TaskStatus(str, Enum):
    PENDING = "pending"
    RUNNING = "running"
    COMPLETED = "completed"
    FAILED = "failed"
    CANCELLED = "cancelled"

class ProcessingOptions(BaseModel):
    split_pages: bool = False
    output_format: str = "markdown"
    language: str = "auto"

class ProcessingTask(BaseModel):
    task_id: str
    file_ids: list[str]
    task_type: TaskType
    status: TaskStatus
    progress: float = 0.0
    current_step: str = ""
    created_time: datetime
    completed_time: Optional[datetime] = None
    session_id: str
    options: ProcessingOptions
    result_files: list[str] = []
    error_message: Optional[str] = None
    estimated_time: Optional[int] = None
```

#### 2.2.3 结果模型
```python
class ResultFile(BaseModel):
    file_id: str
    filename: str
    content_type: str
    size: int
    download_url: str

class ProcessingResult(BaseModel):
    task_id: str
    status: TaskStatus
    results: list[ResultFile]
    summary: dict
    created_time: datetime
    completed_time: Optional[datetime] = None
```

## 3. 前端组件规范

### 3.1 Vue.js组件结构

#### 3.1.1 文件上传组件
```vue
<!-- FileUploader.vue -->
<template>
  <div class="file-uploader">
    <el-upload
      class="upload-demo"
      drag
      multiple
      :action="uploadUrl"
      :before-upload="beforeUpload"
      :on-success="onSuccess"
      :on-error="onError"
      :on-progress="onProgress"
      :file-list="fileList"
    >
      <el-icon class="el-icon--upload"><upload-filled /></el-icon>
      <div class="el-upload__text">
        将文件拖到此处，或<em>点击上传</em>
      </div>
      <template #tip>
        <div class="el-upload__tip">
          支持PDF、PNG、JPG格式，单个文件不超过50MB
        </div>
      </template>
    </el-upload>
  </div>
</template>

<script setup lang="ts">
import { ref, computed } from 'vue'
import { ElMessage } from 'element-plus'
import { UploadFilled } from '@element-plus/icons-vue'
import type { UploadFile, UploadFiles } from 'element-plus'

// Props
interface Props {
  maxFiles?: number
  maxSize?: number // MB
  acceptedTypes?: string[]
}

const props = withDefaults(defineProps<Props>(), {
  maxFiles: 20,
  maxSize: 50,
  acceptedTypes: () => ['application/pdf', 'image/png', 'image/jpeg']
})

// Emits
const emit = defineEmits<{
  'upload-success': [files: any[]]
  'upload-error': [error: string]
}>()

// State
const fileList = ref<UploadFiles>([])
const uploadUrl = computed(() => '/api/v1/files/upload')

// Methods
const beforeUpload = (file: UploadFile) => {
  // 文件类型检查
  if (!props.acceptedTypes.includes(file.type!)) {
    ElMessage.error('不支持的文件类型')
    return false
  }
  
  // 文件大小检查
  if (file.size! / 1024 / 1024 > props.maxSize) {
    ElMessage.error(`文件大小不能超过${props.maxSize}MB`)
    return false
  }
  
  // 文件数量检查
  if (fileList.value.length >= props.maxFiles) {
    ElMessage.error(`最多只能上传${props.maxFiles}个文件`)
    return false
  }
  
  return true
}

const onSuccess = (response: any, file: UploadFile) => {
  if (response.success) {
    emit('upload-success', response.data.files)
    ElMessage.success('文件上传成功')
  } else {
    emit('upload-error', response.message)
    ElMessage.error(response.message)
  }
}

const onError = (error: any) => {
  emit('upload-error', '文件上传失败')
  ElMessage.error('文件上传失败')
}

const onProgress = (event: any, file: UploadFile) => {
  // 更新上传进度
}
</script>
```

#### 3.1.2 任务管理组件
```vue
<!-- TaskManager.vue -->
<template>
  <div class="task-manager">
    <el-card class="task-card" v-for="task in tasks" :key="task.task_id">
      <template #header>
        <div class="card-header">
          <span>{{ getTaskTitle(task) }}</span>
          <el-tag :type="getStatusType(task.status)">
            {{ getStatusText(task.status) }}
          </el-tag>
        </div>
      </template>
      
      <div class="task-content">
        <div class="task-info">
          <p>文件数量: {{ task.file_ids.length }}</p>
          <p>创建时间: {{ formatTime(task.created_time) }}</p>
          <p v-if="task.current_step">当前步骤: {{ task.current_step }}</p>
        </div>
        
        <div class="task-progress" v-if="task.status === 'running'">
          <el-progress 
            :percentage="Math.round(task.progress * 100)"
            :status="task.status === 'failed' ? 'exception' : undefined"
          />
        </div>
        
        <div class="task-actions">
          <el-button 
            v-if="task.status === 'completed'" 
            type="primary" 
            @click="downloadResults(task.task_id)"
          >
            下载结果
          </el-button>
          <el-button 
            v-if="['pending', 'running'].includes(task.status)" 
            type="danger" 
            @click="cancelTask(task.task_id)"
          >
            取消任务
          </el-button>
        </div>
      </div>
    </el-card>
  </div>
</template>

<script setup lang="ts">
import { ref, onMounted, onUnmounted } from 'vue'
import type { ProcessingTask } from '@/types'
import { taskApi } from '@/api/task'

// State
const tasks = ref<ProcessingTask[]>([])
const ws = ref<WebSocket | null>(null)

// Methods
const loadTasks = async () => {
  try {
    const response = await taskApi.getTasks()
    tasks.value = response.data.tasks
  } catch (error) {
    console.error('加载任务列表失败:', error)
  }
}

const connectWebSocket = (taskId: string) => {
  ws.value = new WebSocket(`ws://localhost:8000/ws/tasks/${taskId}`)
  
  ws.value.onmessage = (event) => {
    const message = JSON.parse(event.data)
    if (message.type === 'progress_update') {
      updateTaskProgress(message.data)
    }
  }
}

const updateTaskProgress = (data: any) => {
  const task = tasks.value.find(t => t.task_id === data.task_id)
  if (task) {
    Object.assign(task, data)
  }
}

const downloadResults = async (taskId: string) => {
  try {
    const response = await taskApi.downloadResults(taskId)
    // 处理文件下载
  } catch (error) {
    console.error('下载失败:', error)
  }
}

const cancelTask = async (taskId: string) => {
  try {
    await taskApi.cancelTask(taskId)
    await loadTasks()
  } catch (error) {
    console.error('取消任务失败:', error)
  }
}

// Lifecycle
onMounted(() => {
  loadTasks()
})

onUnmounted(() => {
  if (ws.value) {
    ws.value.close()
  }
})
</script>
```

### 3.2 API调用封装

#### 3.2.1 HTTP客户端配置
```typescript
// api/client.ts
import axios from 'axios'
import type { AxiosInstance, AxiosResponse } from 'axios'

const client: AxiosInstance = axios.create({
  baseURL: '/api/v1',
  timeout: 30000,
  headers: {
    'Content-Type': 'application/json',
  },
})

// 请求拦截器
client.interceptors.request.use(
  (config) => {
    // 添加会话ID
    const sessionId = localStorage.getItem('session_id')
    if (sessionId) {
      config.headers['X-Session-ID'] = sessionId
    }
    return config
  },
  (error) => {
    return Promise.reject(error)
  }
)

// 响应拦截器
client.interceptors.response.use(
  (response: AxiosResponse) => {
    return response.data
  },
  (error) => {
    // 统一错误处理
    const message = error.response?.data?.message || '请求失败'
    console.error('API Error:', message)
    return Promise.reject(new Error(message))
  }
)

export default client
```

#### 3.2.2 文件API
```typescript
// api/file.ts
import client from './client'
import type { FileInfo } from '@/types'

export const fileApi = {
  // 上传文件
  upload: (files: FileList): Promise<{ files: FileInfo[], session_id: string }> => {
    const formData = new FormData()
    Array.from(files).forEach(file => {
      formData.append('files', file)
    })
    
    return client.post('/files/upload', formData, {
      headers: {
        'Content-Type': 'multipart/form-data',
      },
    })
  },

  // 获取文件信息
  getFile: (fileId: string): Promise<FileInfo> => {
    return client.get(`/files/${fileId}`)
  },

  // 删除文件
  deleteFile: (fileId: string): Promise<void> => {
    return client.delete(`/files/${fileId}`)
  },
}
```

#### 3.2.3 任务API
```typescript
// api/task.ts
import client from './client'
import type { ProcessingTask, ProcessingResult } from '@/types'

export const taskApi = {
  // 创建任务
  createTask: (data: {
    file_ids: string[]
    task_type: string
    options?: any
  }): Promise<ProcessingTask> => {
    return client.post('/tasks/create', data)
  },

  // 获取任务状态
  getTask: (taskId: string): Promise<ProcessingTask> => {
    return client.get(`/tasks/${taskId}`)
  },

  // 获取任务列表
  getTasks: (params?: {
    status?: string
    page?: number
    size?: number
  }): Promise<{ tasks: ProcessingTask[], total: number }> => {
    return client.get('/tasks', { params })
  },

  // 取消任务
  cancelTask: (taskId: string): Promise<void> => {
    return client.delete(`/tasks/${taskId}`)
  },

  // 获取结果
  getResults: (taskId: string): Promise<ProcessingResult> => {
    return client.get(`/results/${taskId}`)
  },

  // 下载结果
  downloadResults: (taskId: string): Promise<Blob> => {
    return client.get(`/results/${taskId}/download`, {
      responseType: 'blob'
    })
  },
}
```

## 4. 安全规范

### 4.1 文件上传安全

#### 4.1.1 文件类型验证
```python
ALLOWED_MIME_TYPES = {
    'application/pdf',
    'image/png',
    'image/jpeg',
    'image/jpg',
    'image/tiff',
    'image/bmp'
}

ALLOWED_EXTENSIONS = {'.pdf', '.png', '.jpg', '.jpeg', '.tiff', '.bmp'}

def validate_file_type(file: UploadFile) -> bool:
    # MIME类型检查
    if file.content_type not in ALLOWED_MIME_TYPES:
        return False
    
    # 文件扩展名检查
    file_ext = Path(file.filename).suffix.lower()
    if file_ext not in ALLOWED_EXTENSIONS:
        return False
    
    # 文件头检查（魔数验证）
    file_content = file.file.read(1024)
    file.file.seek(0)  # 重置文件指针
    
    return validate_file_header(file_content, file_ext)
```

#### 4.1.2 文件大小限制
```python
MAX_FILE_SIZE = 50 * 1024 * 1024  # 50MB
MAX_TOTAL_SIZE = 200 * 1024 * 1024  # 200MB
MAX_FILES_PER_REQUEST = 20

def validate_file_size(files: List[UploadFile]) -> bool:
    if len(files) > MAX_FILES_PER_REQUEST:
        raise HTTPException(400, "文件数量超过限制")
    
    total_size = sum(file.size for file in files)
    if total_size > MAX_TOTAL_SIZE:
        raise HTTPException(413, "文件总大小超过限制")
    
    for file in files:
        if file.size > MAX_FILE_SIZE:
            raise HTTPException(413, f"文件 {file.filename} 超过大小限制")
    
    return True
```

### 4.2 访问控制

#### 4.2.1 请求频率限制
```python
from slowapi import Limiter, _rate_limit_exceeded_handler
from slowapi.util import get_remote_address

limiter = Limiter(key_func=get_remote_address)

@app.post("/files/upload")
@limiter.limit("10/minute")  # 每分钟最多10次上传
async def upload_files(request: Request, ...):
    pass

@app.post("/tasks/create")
@limiter.limit("30/minute")  # 每分钟最多30个任务
async def create_task(request: Request, ...):
    pass
```

#### 4.2.2 会话管理
```python
import secrets
from datetime import datetime, timedelta

class SessionManager:
    def __init__(self, redis_client):
        self.redis = redis_client
    
    def create_session(self) -> str:
        session_id = secrets.token_urlsafe(32)
        session_data = {
            'created_time': datetime.now().isoformat(),
            'last_activity': datetime.now().isoformat(),
            'file_count': 0,
            'task_count': 0
        }
        
        self.redis.hset(f"session:{session_id}", mapping=session_data)
        self.redis.expire(f"session:{session_id}", 86400)  # 24小时过期
        
        return session_id
    
    def validate_session(self, session_id: str) -> bool:
        return self.redis.exists(f"session:{session_id}")
    
    def update_activity(self, session_id: str):
        self.redis.hset(
            f"session:{session_id}", 
            'last_activity', 
            datetime.now().isoformat()
        )
```

### 4.3 数据验证

#### 4.3.1 输入参数验证
```python
from pydantic import BaseModel, Field, validator
from typing import List, Optional

class CreateTaskRequest(BaseModel):
    file_ids: List[str] = Field(..., min_items=1, max_items=20)
    task_type: str = Field(..., regex=r'^(full|text|formula|table)$')
    options: Optional[dict] = None
    
    @validator('file_ids')
    def validate_file_ids(cls, v):
        for file_id in v:
            if not re.match(r'^[a-f0-9-]{36}$', file_id):
                raise ValueError('无效的文件ID格式')
        return v
    
    @validator('options')
    def validate_options(cls, v):
        if v is None:
            return {}
        
        allowed_keys = {'split_pages', 'output_format', 'language'}
        if not set(v.keys()).issubset(allowed_keys):
            raise ValueError('包含不允许的选项参数')
        
        return v
```

## 5. 性能规范

### 5.1 异步处理

#### 5.1.1 Celery任务队列
```python
from celery import Celery

celery_app = Celery(
    'file_processor',
    broker='redis://localhost:6379/0',
    backend='redis://localhost:6379/0'
)

@celery_app.task(bind=True)
def process_files_task(self, task_id: str, file_paths: List[str], options: dict):
    try:
        # 更新任务状态
        update_task_status(task_id, 'running', 0.0)
        
        results = []
        total_files = len(file_paths)
        
        for i, file_path in enumerate(file_paths):
            # 处理单个文件
            result = process_single_file(file_path, options)
            results.append(result)
            
            # 更新进度
            progress = (i + 1) / total_files
            update_task_status(task_id, 'running', progress)
            
            # 发送WebSocket消息
            send_progress_update(task_id, progress, f"处理第{i+1}个文件")
        
        # 完成任务
        update_task_status(task_id, 'completed', 1.0, results)
        
    except Exception as e:
        update_task_status(task_id, 'failed', 0.0, error=str(e))
        raise
```

#### 5.1.2 WebSocket实时通信
```python
from fastapi import WebSocket, WebSocketDisconnect
import json

class ConnectionManager:
    def __init__(self):
        self.active_connections: Dict[str, WebSocket] = {}
    
    async def connect(self, websocket: WebSocket, task_id: str):
        await websocket.accept()
        self.active_connections[task_id] = websocket
    
    def disconnect(self, task_id: str):
        if task_id in self.active_connections:
            del self.active_connections[task_id]
    
    async def send_message(self, task_id: str, message: dict):
        if task_id in self.active_connections:
            try:
                await self.active_connections[task_id].send_text(
                    json.dumps(message)
                )
            except:
                self.disconnect(task_id)

manager = ConnectionManager()

@app.websocket("/ws/tasks/{task_id}")
async def websocket_endpoint(websocket: WebSocket, task_id: str):
    await manager.connect(websocket, task_id)
    try:
        while True:
            # 保持连接
            await websocket.receive_text()
    except WebSocketDisconnect:
        manager.disconnect(task_id)
```

### 5.2 缓存策略

#### 5.2.1 Redis缓存配置
```python
import redis
from functools import wraps

redis_client = redis.Redis(
    host='localhost',
    port=6379,
    db=0,
    decode_responses=True,
    socket_connect_timeout=5,
    socket_timeout=5,
    retry_on_timeout=True
)

def cache_result(expire: int = 3600):
    def decorator(func):
        @wraps(func)
        async def wrapper(*args, **kwargs):
            # 生成缓存键
            cache_key = f"{func.__name__}:{hash(str(args) + str(kwargs))}"
            
            # 尝试从缓存获取
            cached = redis_client.get(cache_key)
            if cached:
                return json.loads(cached)
            
            # 执行函数并缓存结果
            result = await func(*args, **kwargs)
            redis_client.setex(
                cache_key, 
                expire, 
                json.dumps(result, default=str)
            )
            
            return result
        return wrapper
    return decorator
```

---

**规范版本**：v1.0  
**制定时间**：2025年1月  
**适用范围**：文件处理网站项目  
**维护者**：开发团队
