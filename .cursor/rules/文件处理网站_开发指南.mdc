---
description: 
globs: 
alwaysApply: false
---
# 文件处理网站开发指南

## 1. 开发环境搭建

### 1.1 系统要求
- **操作系统**：macOS 10.15+ / Ubuntu 18.04+ / Windows 10+
- **Python**：3.9+
- **Node.js**：18+
- **Git**：2.20+
- **Docker**：20.10+ (可选)
- **GPU**：NVIDIA GPU (推荐，用于本地测试)

### 1.2 环境安装

#### 1.2.1 Python环境
```bash
# 使用pyenv管理Python版本
curl https://pyenv.run | bash

# 安装Python 3.9
pyenv install 3.9.18
pyenv global 3.9.18

# 创建虚拟环境
python -m venv venv
source venv/bin/activate  # Linux/macOS
# venv\Scripts\activate   # Windows

# 安装依赖
pip install -r backend/requirements.txt
pip install -r backend/requirements-dev.txt
```

#### 1.2.2 Node.js环境
```bash
# 使用nvm管理Node.js版本
curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.0/install.sh | bash

# 安装Node.js 18
nvm install 18
nvm use 18

# 安装前端依赖
cd frontend
npm install
```

#### 1.2.3 Redis安装
```bash
# Ubuntu/Debian
sudo apt update
sudo apt install redis-server

# macOS
brew install redis

# 启动Redis
redis-server

# Windows (使用Docker)
docker run -d -p 6379:6379 redis:7-alpine
```

### 1.3 项目克隆和配置

#### 1.3.1 克隆项目
```bash
git clone <repository-url> file_processing_website
cd file_processing_website

# 复制MonkeyOCR核心代码
cp -r ../MonkeyOCR/magic_pdf ./
cp ../MonkeyOCR/model_configs.yaml ./
```

#### 1.3.2 环境变量配置
```bash
# 创建环境变量文件
cp .env.example .env

# 编辑环境变量
cat > .env << EOF
# 开发环境配置
DEBUG=true
ENVIRONMENT=development

# Redis配置
REDIS_URL=redis://localhost:6379/0

# 文件存储配置
STORAGE_PATH=./storage
MAX_FILE_SIZE=52428800  # 50MB
MAX_TOTAL_SIZE=209715200  # 200MB

# MonkeyOCR配置
MODEL_CONFIGS_PATH=./model_configs.yaml
MODELS_DIR=./model_weight

# 日志配置
LOG_LEVEL=INFO
LOG_DIR=./logs

# CORS配置
ALLOWED_ORIGINS=http://localhost:3000,http://127.0.0.1:3000
EOF
```

#### 1.3.3 创建必要目录
```bash
mkdir -p storage/{uploads,processing,results}
mkdir -p model_weight
mkdir -p logs
```

### 1.4 开发工具配置

#### 1.4.1 VS Code配置
```json
// .vscode/settings.json
{
  "python.defaultInterpreterPath": "./venv/bin/python",
  "python.linting.enabled": true,
  "python.linting.pylintEnabled": false,
  "python.linting.flake8Enabled": true,
  "python.formatting.provider": "black",
  "python.formatting.blackArgs": ["--line-length", "88"],
  "editor.formatOnSave": true,
  "editor.codeActionsOnSave": {
    "source.organizeImports": true
  },
  "files.exclude": {
    "**/__pycache__": true,
    "**/*.pyc": true,
    "**/node_modules": true,
    "**/dist": true
  }
}
```

#### 1.4.2 推荐扩展
```json
// .vscode/extensions.json
{
  "recommendations": [
    "ms-python.python",
    "ms-python.black-formatter",
    "ms-python.flake8",
    "ms-python.isort",
    "bradlc.vscode-tailwindcss",
    "vue.volar",
    "ms-vscode.vscode-typescript-next",
    "esbenp.prettier-vscode",
    "ms-vscode.vscode-docker"
  ]
}
```

## 2. 开发流程

### 2.1 Git工作流

#### 2.1.1 分支策略
```
main           # 主分支，生产环境代码
├── develop    # 开发分支，集成测试
├── feature/*  # 功能分支
├── bugfix/*   # 修复分支
└── hotfix/*   # 热修复分支
```

#### 2.1.2 提交规范
```bash
# 提交消息格式
<type>(<scope>): <description>

# 类型说明
feat:     新功能
fix:      修复bug
docs:     文档更新
style:    代码格式调整
refactor: 重构代码
test:     测试相关
chore:    构建过程或辅助工具的变动

# 示例
feat(upload): 添加文件拖拽上传功能
fix(api): 修复文件大小验证问题
docs(readme): 更新部署说明
```

#### 2.1.3 开发流程
```bash
# 1. 从主分支创建功能分支
git checkout main
git pull origin main
git checkout -b feature/file-upload

# 2. 开发功能
# ... 编写代码 ...

# 3. 提交代码
git add .
git commit -m "feat(upload): 实现文件上传基础功能"

# 4. 推送分支
git push origin feature/file-upload

# 5. 创建Pull Request
# 在GitHub/GitLab上创建PR，请求合并到develop分支

# 6. 代码审查通过后合并
git checkout develop
git pull origin develop
git branch -d feature/file-upload
```

### 2.2 开发环境启动

#### 2.2.1 后端启动
```bash
# 激活虚拟环境
source venv/bin/activate

# 启动Redis
redis-server

# 启动后端服务
cd backend
uvicorn app.main:app --reload --host 0.0.0.0 --port 8000

# 启动Celery Worker (新终端)
celery -A app.celery_app worker --loglevel=info
```

#### 2.2.2 前端启动
```bash
# 启动开发服务器
cd frontend
npm run dev

# 访问地址: http://localhost:3000
```

#### 2.2.3 使用Docker启动
```bash
# 启动开发环境
docker-compose -f docker/docker-compose.dev.yml up -d

# 查看日志
docker-compose -f docker/docker-compose.dev.yml logs -f

# 停止服务
docker-compose -f docker/docker-compose.dev.yml down
```

## 3. 代码规范

### 3.1 Python代码规范

#### 3.1.1 代码格式化
```python
# 使用Black进行代码格式化
# pyproject.toml
[tool.black]
line-length = 88
target-version = ['py39']
include = '\.pyi?$'
extend-exclude = '''
/(
  # directories
  \.eggs
  | \.git
  | \.hg
  | \.mypy_cache
  | \.tox
  | \.venv
  | build
  | dist
)/
'''
```

#### 3.1.2 导入排序
```python
# 使用isort进行导入排序
# .isort.cfg
[settings]
profile = black
multi_line_output = 3
line_length = 88
known_first_party = app,magic_pdf
sections = FUTURE,STDLIB,THIRDPARTY,FIRSTPARTY,LOCALFOLDER
```

#### 3.1.3 类型注解
```python
from typing import List, Optional, Dict, Any
from pydantic import BaseModel

class FileUploadRequest(BaseModel):
    files: List[str]
    options: Optional[Dict[str, Any]] = None

async def process_files(
    file_ids: List[str],
    task_type: str,
    session_id: str
) -> Dict[str, Any]:
    """
    处理文件的异步函数
    
    Args:
        file_ids: 文件ID列表
        task_type: 任务类型
        session_id: 会话ID
        
    Returns:
        处理结果字典
        
    Raises:
        ValueError: 当参数无效时
        ProcessingError: 当处理失败时
    """
    pass
```

#### 3.1.4 错误处理
```python
from app.core.exceptions import ProcessingError, ValidationError

class FileProcessor:
    def process_file(self, file_path: str) -> Dict[str, Any]:
        try:
            # 验证文件
            if not self._validate_file(file_path):
                raise ValidationError(f"无效的文件: {file_path}")
            
            # 处理文件
            result = self._do_process(file_path)
            return result
            
        except FileNotFoundError as e:
            logger.error(f"文件不存在: {file_path}")
            raise ProcessingError(f"文件不存在: {file_path}") from e
        except Exception as e:
            logger.error(f"处理文件失败: {file_path}, 错误: {e}")
            raise ProcessingError(f"处理失败: {str(e)}") from e
```

### 3.2 JavaScript/TypeScript代码规范

#### 3.2.1 ESLint配置
```json
// .eslintrc.js
module.exports = {
  root: true,
  env: {
    node: true,
    browser: true,
    es2021: true
  },
  extends: [
    'plugin:vue/vue3-essential',
    '@vue/typescript/recommended',
    '@vue/prettier'
  ],
  parserOptions: {
    ecmaVersion: 2021
  },
  rules: {
    'no-console': process.env.NODE_ENV === 'production' ? 'warn' : 'off',
    'no-debugger': process.env.NODE_ENV === 'production' ? 'warn' : 'off',
    '@typescript-eslint/no-explicit-any': 'warn',
    '@typescript-eslint/no-unused-vars': 'error'
  }
}
```

#### 3.2.2 Prettier配置
```json
// .prettierrc
{
  "semi": false,
  "singleQuote": true,
  "tabWidth": 2,
  "trailingComma": "es5",
  "printWidth": 80,
  "endOfLine": "lf"
}
```

#### 3.2.3 Vue组件规范
```vue
<template>
  <div class="file-uploader">
    <!-- 组件内容 -->
  </div>
</template>

<script setup lang="ts">
// 导入
import { ref, computed, onMounted } from 'vue'
import type { UploadFile } from 'element-plus'

// 接口定义
interface Props {
  maxFiles?: number
  acceptedTypes?: string[]
}

interface Emits {
  (e: 'upload-success', files: any[]): void
  (e: 'upload-error', error: string): void
}

// Props和Emits
const props = withDefaults(defineProps<Props>(), {
  maxFiles: 20,
  acceptedTypes: () => ['application/pdf', 'image/png']
})

const emit = defineEmits<Emits>()

// 响应式数据
const fileList = ref<UploadFile[]>([])
const isUploading = ref(false)

// 计算属性
const uploadUrl = computed(() => '/api/v1/files/upload')

// 方法
const handleUpload = async (file: UploadFile) => {
  try {
    isUploading.value = true
    // 上传逻辑
    emit('upload-success', [])
  } catch (error) {
    emit('upload-error', '上传失败')
  } finally {
    isUploading.value = false
  }
}

// 生命周期
onMounted(() => {
  // 初始化逻辑
})
</script>

<style scoped>
.file-uploader {
  /* 样式 */
}
</style>
```

### 3.3 CSS/SCSS规范

#### 3.3.1 命名规范
```scss
// BEM命名规范
.file-uploader {
  &__header {
    // 元素样式
  }
  
  &__button {
    // 元素样式
    
    &--primary {
      // 修饰符样式
    }
    
    &--disabled {
      // 修饰符样式
    }
  }
  
  &--loading {
    // 修饰符样式
  }
}
```

#### 3.3.2 Tailwind CSS使用
```vue
<template>
  <div class="flex flex-col space-y-4 p-6 bg-white rounded-lg shadow-md">
    <h2 class="text-xl font-semibold text-gray-800">文件上传</h2>
    <div class="border-2 border-dashed border-gray-300 rounded-lg p-8 text-center hover:border-blue-400 transition-colors">
      <!-- 上传区域 -->
    </div>
  </div>
</template>
```

## 4. 测试指南

### 4.1 后端测试

#### 4.1.1 单元测试
```python
# tests/test_file_manager.py
import pytest
from unittest.mock import Mock, patch
from app.services.file_manager import FileManager
from app.core.exceptions import ValidationError

class TestFileManager:
    @pytest.fixture
    def file_manager(self):
        return FileManager()
    
    def test_validate_file_type_success(self, file_manager):
        """测试文件类型验证成功"""
        mock_file = Mock()
        mock_file.content_type = 'application/pdf'
        mock_file.filename = 'test.pdf'
        
        result = file_manager.validate_file_type(mock_file)
        assert result is True
    
    def test_validate_file_type_invalid(self, file_manager):
        """测试文件类型验证失败"""
        mock_file = Mock()
        mock_file.content_type = 'text/plain'
        mock_file.filename = 'test.txt'
        
        with pytest.raises(ValidationError):
            file_manager.validate_file_type(mock_file)
    
    @patch('app.services.file_manager.os.makedirs')
    def test_create_storage_directory(self, mock_makedirs, file_manager):
        """测试创建存储目录"""
        file_manager.create_storage_directory('/test/path')
        mock_makedirs.assert_called_once_with('/test/path', exist_ok=True)
```

#### 4.1.2 集成测试
```python
# tests/test_api.py
import pytest
from fastapi.testclient import TestClient
from app.main import app

client = TestClient(app)

class TestFileAPI:
    def test_upload_file_success(self):
        """测试文件上传成功"""
        with open('tests/fixtures/test.pdf', 'rb') as f:
            response = client.post(
                '/api/v1/files/upload',
                files={'files': ('test.pdf', f, 'application/pdf')}
            )
        
        assert response.status_code == 200
        data = response.json()
        assert data['success'] is True
        assert len(data['data']['files']) == 1
    
    def test_upload_file_invalid_type(self):
        """测试上传无效文件类型"""
        with open('tests/fixtures/test.txt', 'rb') as f:
            response = client.post(
                '/api/v1/files/upload',
                files={'files': ('test.txt', f, 'text/plain')}
            )
        
        assert response.status_code == 415
        data = response.json()
        assert data['success'] is False
```

#### 4.1.3 测试运行
```bash
# 安装测试依赖
pip install pytest pytest-asyncio pytest-cov

# 运行所有测试
pytest

# 运行特定测试文件
pytest tests/test_file_manager.py

# 运行测试并生成覆盖率报告
pytest --cov=app --cov-report=html

# 运行测试并显示详细输出
pytest -v -s
```

### 4.2 前端测试

#### 4.2.1 单元测试配置
```typescript
// vitest.config.ts
import { defineConfig } from 'vitest/config'
import vue from '@vitejs/plugin-vue'
import { resolve } from 'path'

export default defineConfig({
  plugins: [vue()],
  test: {
    environment: 'jsdom',
    globals: true,
    setupFiles: ['tests/setup.ts']
  },
  resolve: {
    alias: {
      '@': resolve(__dirname, 'src')
    }
  }
})
```

#### 4.2.2 组件测试
```typescript
// tests/components/FileUploader.test.ts
import { describe, it, expect, vi } from 'vitest'
import { mount } from '@vue/test-utils'
import FileUploader from '@/components/FileUploader.vue'

describe('FileUploader', () => {
  it('renders correctly', () => {
    const wrapper = mount(FileUploader)
    expect(wrapper.find('.file-uploader').exists()).toBe(true)
  })
  
  it('emits upload-success when file is uploaded', async () => {
    const wrapper = mount(FileUploader)
    const mockFile = new File(['test'], 'test.pdf', { type: 'application/pdf' })
    
    // 模拟文件上传
    await wrapper.vm.handleUpload(mockFile)
    
    expect(wrapper.emitted('upload-success')).toBeTruthy()
  })
  
  it('validates file type correctly', () => {
    const wrapper = mount(FileUploader, {
      props: {
        acceptedTypes: ['application/pdf']
      }
    })
    
    const validFile = new File(['test'], 'test.pdf', { type: 'application/pdf' })
    const invalidFile = new File(['test'], 'test.txt', { type: 'text/plain' })
    
    expect(wrapper.vm.validateFileType(validFile)).toBe(true)
    expect(wrapper.vm.validateFileType(invalidFile)).toBe(false)
  })
})
```

#### 4.2.3 E2E测试
```typescript
// tests/e2e/upload.spec.ts
import { test, expect } from '@playwright/test'

test.describe('File Upload', () => {
  test('should upload file successfully', async ({ page }) => {
    await page.goto('http://localhost:3000')
    
    // 选择文件
    const fileInput = page.locator('input[type="file"]')
    await fileInput.setInputFiles('tests/fixtures/test.pdf')
    
    // 点击上传按钮
    await page.click('button:has-text("上传")')
    
    // 验证上传成功
    await expect(page.locator('.success-message')).toBeVisible()
    await expect(page.locator('.file-list')).toContainText('test.pdf')
  })
  
  test('should show error for invalid file type', async ({ page }) => {
    await page.goto('http://localhost:3000')
    
    // 选择无效文件
    const fileInput = page.locator('input[type="file"]')
    await fileInput.setInputFiles('tests/fixtures/test.txt')
    
    // 验证错误消息
    await expect(page.locator('.error-message')).toBeVisible()
    await expect(page.locator('.error-message')).toContainText('不支持的文件类型')
  })
})
```

### 4.3 API测试

#### 4.3.1 Postman集合
```json
{
  "info": {
    "name": "File Processing API",
    "schema": "https://schema.getpostman.com/json/collection/v2.1.0/collection.json"
  },
  "item": [
    {
      "name": "Upload File",
      "request": {
        "method": "POST",
        "header": [],
        "body": {
          "mode": "formdata",
          "formdata": [
            {
              "key": "files",
              "type": "file",
              "src": "test.pdf"
            }
          ]
        },
        "url": {
          "raw": "{{baseUrl}}/api/v1/files/upload",
          "host": ["{{baseUrl}}"],
          "path": ["api", "v1", "files", "upload"]
        }
      },
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              "pm.test('Status code is 200', function () {",
              "    pm.response.to.have.status(200);",
              "});",
              "",
              "pm.test('Response has file data', function () {",
              "    const jsonData = pm.response.json();",
              "    pm.expect(jsonData.success).to.be.true;",
              "    pm.expect(jsonData.data.files).to.be.an('array');",
              "});"
            ]
          }
        }
      ]
    }
  ]
}
```

## 5. 调试指南

### 5.1 后端调试

#### 5.1.1 VS Code调试配置
```json
// .vscode/launch.json
{
  "version": "0.2.0",
  "configurations": [
    {
      "name": "Python: FastAPI",
      "type": "python",
      "request": "launch",
      "program": "${workspaceFolder}/backend/app/main.py",
      "console": "integratedTerminal",
      "cwd": "${workspaceFolder}/backend",
      "env": {
        "PYTHONPATH": "${workspaceFolder}/backend"
      },
      "args": ["--reload", "--host", "0.0.0.0", "--port", "8000"]
    },
    {
      "name": "Python: Celery Worker",
      "type": "python",
      "request": "launch",
      "module": "celery",
      "console": "integratedTerminal",
      "cwd": "${workspaceFolder}/backend",
      "args": ["-A", "app.celery_app", "worker", "--loglevel=debug"]
    }
  ]
}
```

#### 5.1.2 日志调试
```python
from loguru import logger

# 添加调试日志
logger.debug("处理文件: {}", file_path)
logger.info("任务状态更新: {} -> {}", old_status, new_status)
logger.warning("文件大小超过建议值: {} MB", file_size / 1024 / 1024)
logger.error("处理失败: {}", error)

# 结构化日志
logger.bind(task_id=task_id, user_id=user_id).info("开始处理任务")
```

### 5.2 前端调试

#### 5.2.1 Vue DevTools
```vue
<script setup lang="ts">
import { ref } from 'vue'

// 开发环境下暴露到全局，便于调试
if (process.env.NODE_ENV === 'development') {
  window.debugData = {
    fileList,
    uploadProgress,
    taskStatus
  }
}
</script>
```

#### 5.2.2 网络请求调试
```typescript
// api/client.ts
import axios from 'axios'

const client = axios.create({
  baseURL: '/api/v1'
})

// 请求拦截器 - 添加调试信息
client.interceptors.request.use(config => {
  if (process.env.NODE_ENV === 'development') {
    console.log('API Request:', config.method?.toUpperCase(), config.url, config.data)
  }
  return config
})

// 响应拦截器 - 添加调试信息
client.interceptors.response.use(
  response => {
    if (process.env.NODE_ENV === 'development') {
      console.log('API Response:', response.status, response.data)
    }
    return response.data
  },
  error => {
    if (process.env.NODE_ENV === 'development') {
      console.error('API Error:', error.response?.status, error.response?.data)
    }
    return Promise.reject(error)
  }
)
```

## 6. 性能优化

### 6.1 后端优化

#### 6.1.1 异步处理
```python
import asyncio
from concurrent.futures import ThreadPoolExecutor

class FileProcessor:
    def __init__(self):
        self.executor = ThreadPoolExecutor(max_workers=4)
    
    async def process_files_async(self, file_paths: List[str]) -> List[Dict]:
        """异步处理多个文件"""
        loop = asyncio.get_event_loop()
        tasks = [
            loop.run_in_executor(self.executor, self.process_single_file, path)
            for path in file_paths
        ]
        results = await asyncio.gather(*tasks, return_exceptions=True)
        return results
```

#### 6.1.2 缓存优化
```python
from functools import lru_cache
import redis

# 内存缓存
@lru_cache(maxsize=1000)
def get_file_metadata(file_path: str) -> Dict[str, Any]:
    """获取文件元数据（带缓存）"""
    return extract_metadata(file_path)

# Redis缓存
class CacheManager:
    def __init__(self, redis_client):
        self.redis = redis_client
    
    async def get_or_set(self, key: str, func, expire: int = 3600):
        """获取缓存或设置新值"""
        cached = await self.redis.get(key)
        if cached:
            return json.loads(cached)
        
        result = await func()
        await self.redis.setex(key, expire, json.dumps(result, default=str))
        return result
```

### 6.2 前端优化

#### 6.2.1 代码分割
```typescript
// router/index.ts
import { createRouter, createWebHistory } from 'vue-router'

const router = createRouter({
  history: createWebHistory(),
  routes: [
    {
      path: '/',
      component: () => import('@/views/Home.vue')  // 懒加载
    },
    {
      path: '/upload',
      component: () => import('@/views/Upload.vue')  // 懒加载
    }
  ]
})
```

#### 6.2.2 虚拟滚动
```vue
<template>
  <div class="virtual-list" ref="containerRef" @scroll="handleScroll">
    <div class="list-content" :style="{ height: totalHeight + 'px' }">
      <div
        v-for="item in visibleItems"
        :key="item.id"
        class="list-item"
        :style="{ transform: `translateY(${item.top}px)` }"
      >
        {{ item.data }}
      </div>
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref, computed, onMounted } from 'vue'

const props = defineProps<{
  items: any[]
  itemHeight: number
}>()

const containerRef = ref<HTMLElement>()
const scrollTop = ref(0)
const containerHeight = ref(0)

const visibleItems = computed(() => {
  const start = Math.floor(scrollTop.value / props.itemHeight)
  const end = Math.min(
    start + Math.ceil(containerHeight.value / props.itemHeight) + 1,
    props.items.length
  )
  
  return props.items.slice(start, end).map((item, index) => ({
    ...item,
    top: (start + index) * props.itemHeight
  }))
})

const totalHeight = computed(() => props.items.length * props.itemHeight)

const handleScroll = (e: Event) => {
  scrollTop.value = (e.target as HTMLElement).scrollTop
}
</script>
```

## 7. 部署和发布

### 7.1 构建流程

#### 7.1.1 前端构建
```bash
# 安装依赖
npm ci

# 类型检查
npm run type-check

# 代码检查
npm run lint

# 单元测试
npm run test:unit

# 构建生产版本
npm run build

# 构建分析
npm run build:analyze
```

#### 7.1.2 后端构建
```bash
# 激活虚拟环境
source venv/bin/activate

# 安装依赖
pip install -r requirements.txt

# 代码检查
flake8 app/
black --check app/
isort --check-only app/

# 类型检查
mypy app/

# 单元测试
pytest --cov=app

# 构建Docker镜像
docker build -f docker/Dockerfile.backend -t file-processor-backend .
```

### 7.2 CI/CD配置

#### 7.2.1 GitHub Actions
```yaml
# .github/workflows/ci.yml
name: CI/CD Pipeline

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main]

jobs:
  test-backend:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.9'
          
      - name: Install dependencies
        run: |
          pip install -r backend/requirements.txt
          pip install -r backend/requirements-dev.txt
          
      - name: Run tests
        run: |
          cd backend
          pytest --cov=app --cov-report=xml
          
      - name: Upload coverage
        uses: codecov/codecov-action@v3
        with:
          file: ./backend/coverage.xml

  test-frontend:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      
      - name: Set up Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'
          cache: 'npm'
          cache-dependency-path: frontend/package-lock.json
          
      - name: Install dependencies
        run: |
          cd frontend
          npm ci
          
      - name: Run tests
        run: |
          cd frontend
          npm run test:unit
          
      - name: Build
        run: |
          cd frontend
          npm run build

  deploy:
    needs: [test-backend, test-frontend]
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    steps:
      - uses: actions/checkout@v3
      
      - name: Deploy to production
        run: |
          # 部署脚本
          ./scripts/deploy.sh prod
```

---

**文档版本**：v1.0  
**制定时间**：2025年1月  
**适用范围**：文件处理网站项目  
**维护者**：开发团队
